\section{Lezione 08 - 03/10/2023}
\subsection{Nomi Utilizzati delle visite}
Questo piccolo inserto legenda servira per identificare i 2 particolari tipi di visita che effettueremo.
\begin{itemize}
	\item \textbf{DFS} o visite in profondita sono i tipi di visite che prevedono prima la visita dei figli e poi l'operazione che si vuole effettuare.
	\item \textbf{BFS} o visite di \textbf{ampiezza} sono tipi di visite che prevedono l'utilizzo di una coda per l'esplorazione dei figli. Infatti questa visita prevedera prima l'esplorazione del nodo padre e poi la messa in coda dei figli.
\end{itemize}

\subsection{Visita In Ampiezza Albero}
La visita in ampiezza dell'albero e un tipo di visita che prevede la visita dei nodi in modo "orizzontale". Questa visita di prim'occhio potrebbe sembrare piu complessa, poiche rispetto alle altre che abbiamo visto fino ad ora non e possibile effettuarla con un algoritmo ricorsivo/iterativo e basta. Infatti per questa visita ci sara utile l'utilizzo di una struttura dati astratta gia studiata in precedenza che ci consentira l'esplorazione. \textbf{La coda} ci sara utile per effettuare questi tipi di visite.
La coda ci serve per inserire i figli del nodo selezionato all'interno di essa e poi prelevarli per andare a visitarli e a sua volta inserire i suoi figli.

\begin{lstlisting}[language=Java]
	BFS(T):
	Q=NIL
	Q=Accoda(Q,T)
	while(Q!=NIL) DO
		X=Testa(Q)
		"Visita del nodo"
		Q=Accoda(Q,X->sx)
		Q=Accoda(Q,X->dx)
		Q=Decode(Q) //Toglie della coda il primo	
\end{lstlisting}

Ma quanto puo essere complesso fare una cosa del genere? Le operazioni all'interno e prima del while sono a tempo costante perche sono operazioni di assegnazione. Il while pero dipende dalla quantita di nodi all'interno dell'albero. In particolare a seconda se l'albero e bilanciato o meno.

\begin{itemize}
	\item Nel caso peggiore l'albero e un albero degenere, in questo caso la coda avra tutti gli elementi della lista all'interno di essa. Il costo computazionale dunque, a seconda dell'altezza, sara il \textbf{tetto frazionario} di n/2. Dunque la memoria necessaria in questo caso potrebbe richiedere una quantita lineare (per la coda).
	\item Nel caso migliore l'albero e bilanciato, cioe ogni nodo ha 2 figli. A livello di memoria invece sara costante.
\end{itemize}

\subsection{Albero Binario di Ricerca}
E un tipo di albero ordinato, con una relazione che lega tutti i nodi figli. Il vincolo sta a indicare che preso un qualsiasi nodo, esso sara sempre piu piccolo del suo sottoalbero destro, e piu grande del suo sottoalbero sinistro.
L'acronimo per questo albero sara \textbf{BST}. Il motivo per cui e stato introdotto questo albero e per facilitare la ricerca di dati, infatti il suo algoritmo di ricerca e uno dei piu efficienti.

\subsubsection{Search Ricorsiva - BST}

\begin{lstlisting}[language=Java]
	SearchBSTr(T,k)
	ret=T
	if T!= NIL then
		if T->key < k then
			ret = SearchBSTr(T->dx, k)
		else if T->key > k then
			ret = SearchBSTr(T-sx, k)
	return ris	
\end{lstlisting}

Questo algoritmo, sicuramente ci permettera di cercare in modo piu efficiente il dato poiche, un po come la ricerca binaria (ma non propriamente), ci permette di andare a "dimezzare" l'area di ricerca ogni volta che si fa un confronto.\\

Esiste anche la versione iterativa di questo algoritmo:

\begin{lstlisting}[language=Java]
	SearchBSTi(T,k)
	Tmp = T
	while Tmp != NIl && Tmp-> key != k do
		if Tmp->key < k then
			Tmp=Tmp->dx
		else
			Tmp=Tmp->sx
	return Tmp	
\end{lstlisting}

Proprio come l'algoritmo ricorsivo andremo a dividere l'albero in due, ma ci avvarremo di un puntatore temporale per lo scorrimento dell'albero.

\subsubsection{Min - BST}
La ricerca del minimo in un albero binario di ricerca (dunque ordinato) e molto semplice. Se semplicemente seguendo la regola secondo cui "l'elemento piu piccolo si trova a sinistra". Allora andremo a scorrere continuamente a sinistra finche non troveremo l'elemento piu piccolo dell'albero.

\begin{lstlisting}[language=Java]
	MinR(T)
	ret = T
	if ret->sx != NIL then
		ret= MinR(ret->sx)
	return ret
\end{lstlisting}

\subsubsection{Algoritmo del Successore Ricorsivo - BST}
Il successore di un numero e il primo numero piu grande dello stesso. In questo caso l'algoritmo diventa un po piu complesso nelle casistiche:
\begin{itemize}
	\item  Caso in cui l'elemento di cui vogliamo il successore e uguale alla chiave dell'elemento in cui siamo. Caso T->key = k. In questo caso l'elemento che sicuramente sara successore si trovera nel sottoalbero destro. E il piu piccolo elemento del sottoalbero destro sara il nostro risultato che cerchiamo quindi $\rightarrow$ Min(T->dx)
	\item Caso T->key < k. Se il numero di cui cerchiamo il successore si trova ancora in un nodo piu piccolo di esso allora dovremmo spostarci a destra con la stessa funzione. Succ(T->dx).
	\item Caso T->key > k. Se il numero sara piu grande di quello che cerchiamo allora dovremmo spostarci sulla sinistra. (T->sx, k)
\end{itemize}

\begin{lstlisting}[language=Java]
	SuccR(T,k)
	ret = NIL
	if ret != NIL then
		if ret->key = k then
			ret = Min(ret->dx)
			ret = SuccR(ret->dx,k)
		else if ret->key < k then
		else 
			ret = SuccR(T->sx,k)
			if ret= NIL then
				ret = T
\end{lstlisting}

\subsubsection{Algoritmo del Successore Iterativo - BST}

Per questo tipo di algoritmo, dobbiamo ragionare in modo diverso. In questo caso non iterativo non possiamo permetterci di omettere determinati controlli a posteriori. In particolare il controllo nel caso in cui il valore di cui vogliamo il successore non ha figli destri ed e una foglia. In questo caso particolare non abbiamo la possibilita di risalire a ritroso ricorsivamente ma dobbiamo tenere traccia ogni volta che il nodo scende a sinistra, segnandoci il puntatore di quest'ultimo.

\begin{lstlisting}[language=Java]
	SuccI(T,k)
	Tmp = T
	ret = NIL
	while Tmp != NIL andd TMP->key != k then
		if Tmp->key < k then
			Tmp = Tmp->dx
		else 
			ret = Tmp
			Tmp = Tmp->sx
	if Tmp != NIL && Tmp->dx != NIL then
		ret = Min(Tmp->dx)
	return ret
\end{lstlisting}
